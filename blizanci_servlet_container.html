<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module blizanci_servlet_container</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module blizanci_servlet_container</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul> 
This module provides a mechanism for dynamic content generation for 
Gemini requests.

<p><b>Behaviours:</b> <a href="gen_server.html"><tt>gen_server</tt></a>.</p>

<h2><a name="description">Description</a></h2><p> 
This module provides a mechanism for dynamic content generation for 
Gemini requests. Currently it is somewhat hardwired to use CGI to 
fulfil these.</p>

 <p>One blizanci_servlet_container process is generated per deferred 
request. This is done by calling blizanci_servlet_container:request/5, 
which has the side-effect of caching the caller's Pid and passing it to 
the servlet process it creates.</p>

 <p>On completion of the request, which may well not be synchronous, results 
may be communicated back to the Gemini parent (the original caller) by 
sending a message in the following form:</p>

    <p>{servlet_failed, ErrorCode :: atom()}  
| {servlet_complete, Output :: binary()}</p>

 <p>It is likely unnecessary for a handler module to provide substantive 
implementations of both Module:serve/4 and Module:request/4. This is 
because a handler module will likely behave wholly synchronously or 
wholly asychronously.</p>

 A synchrononous handler module should have a substantive implementation
 of Module:request/4 which returns a gemini response marked with the
 atom 'immediate'; this means its implementation of Module:serve/4 will
 never be called and may be left as a stub. Conversely, an asychronous
 handler module would have a trivial implementation of Module:request/4,
 returning the atom 'defer', and the substantive implementation would be
 afforded via its Module:serve/4 implementation instead.

<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#cancel-1">cancel/1</a></td><td></td></tr>
<tr><td valign="top"><a href="#gateway_exit-2">gateway_exit/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#request-5">request/5</a></td><td>Called by the router to dispatch a request to a specific handler.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="cancel-1">cancel/1</a></h3>
<div class="spec">
<p><tt>cancel(X1::<a href="#type-servlet_proc">servlet_proc()</a>) -&gt; ok</tt><br></p>
<p> </p>
</div>

<h3 class="function"><a name="gateway_exit-2">gateway_exit/2</a></h3>
<div class="spec">
<p><tt>gateway_exit(Pid::pid(), Result::<a href="#type-gateway_result">gateway_result()</a>) -&gt; ok</tt><br></p>
<p> </p>
</div>

<h3 class="function"><a name="request-5">request/5</a></h3>
<div class="spec">
<p><tt>request(Module::module(), Matches::<a href="#type-path_matches">path_matches()</a>, Request::any(), ServerConfig::<a href="#type-server_config">server_config()</a>, RouteOpts::any()) -&gt; <a href="#type-gemini_response">gemini_response()</a></tt><br></p>
<p><tt>Module</tt>: the module implementing the handler<br>
<tt>Matches</tt>: a list of binary key-value pairs representing the manner in which the request matched the pattern associated with the route<br>
<tt>Request</tt>: the request<br>
<tt>ServerConfig</tt>: the configuration for the Gemini server<br>
<tt>RouteOpts</tt>: <p>the configuration to be passed to the servlet module</p>
 
  The function calls Module:request(Matches, Request, Config), which may
  return either an immediate Gemini response or the atom 'defer'. Where it
  is indicated that the response will be deferred, a new process is started
  and Module:serve(Matches, Req, Config) is called. This sets things up
  for the results of the request to be notified back to the caller
  (of request/5), which is a ranch handler for the Gemini protocol.<br>
</p>
</div><p>Called by the router to dispatch a request to a specific handler.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
